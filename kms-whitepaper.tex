\documentclass[longbibliography]{revtex4-1}

\newcommand{\kms}{NuCypher KMS}

\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=5pt]{subfig}
\usepackage[usenames]{color}
\renewcommand{\baselinestretch}{1.4}
\setlength{\parskip}{1em}
\definecolor{darkgreen}{rgb}{0.00,0.50,0.25}
\definecolor{darkblue}{rgb}{0.00,0.00,0.67}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\usepackage[breaklinks,pdftitle={NuCypher KMS: decentralized key management system}, pdfauthor={Michael Egorov},colorlinks,urlcolor=blue,citecolor=darkgreen,linkcolor=darkblue]{hyperref}
\usepackage[usenames]{color}
\graphicspath{{pdf/}}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\lstset{
    basicstyle=\ttfamily,
    basewidth={0.5em, 0.5em},
    columns=fullflexible,
}

\begin{document}

\title{\kms: Decentralized key management system}

\author{M. Egorov}
\email{michael@nucypher.com}
\author{M. Wilkison}
\email{maclane@nucypher.com}
\affiliation{NuCypher}


\begin{abstract}
    \kms~is a decentralized Key Management System (KMS) that addresses the limitations of using consensus
    networks to securely store and manipulate private, encrypted data~\cite{cryptoeprint:2017:201}.
    It provides encryption and cryptographic access controls, performed by a decentralized network,
    leveraging proxy re-encryption~\cite{wiki:pre}.
    Unlike centralized KMS as a service solutions, it doesn't require trusting a service provider.
    \kms~enables sharing of sensitive data for both decentralized and centralized applications,
    providing security infrastructure for applications from healthcare to identity management to decentralized content marketplaces.
\end{abstract}

\date{\today}
\maketitle

\tableofcontents


\section{Introduction}

\kms~is a decentralized key management system (KMS), encryption, and access control service.
It enables private data sharing between arbitrary numbers of participants in public consensus networks,
using proxy re-encryption, a hybrid cryptosystem that combines the efficiency of symmetric encryption with the convenience of public-key encryption.
Native tokens are used to incentivize network participants to perform key management and access delegation/revocation operations.

\subsection{Background}
A key management system (KMS) is an integrated approach for generating, distributing, and managing cryptographic keys for devices and
applications.
A KMS includes the backend functionality for key generation, distribution, and rotation as well as the client functionality for
injecting, storing, and managing keys on devices~\cite{wiki:kms}.

As the root of trust, it's critical that a KMS is appropriately configured, managed, and protected.
Historically, this has meant deploying a KMS on-premises in hardware security modules (HSM)~\cite{wiki:hsm} or using tools like
HashiCorp's Vault~\cite{web:hashicorp-vault}.
However, this requires a high degree of technical sophistication as well as upfront capital investment.
To ease the technical burden and provide more competitive pricing, vendors like Amazon CloudHSM~\cite{web:aws-cloudhsm},
Google Cloud KMS~\cite{web:google-cloud-kms}, Azure Key Vault~\cite{web:azure-key-vault} and TrueVault~\cite{web:truevault}
have begun offering KMS as a service.
However, KMS as a service offerings necessitate placing an undue level of trust in the service provider, which may
be inappropriate for security-critical applications.

Public consensus networks, such as Bitcoin and Ethereum, are a promising solution to this centralization problem.
But the limitations of public consensus networks in performing cryptographic operations that involve the manipulation of secret
data are well-established~\cite{cryptoeprint:2017:201}. Consensus networks employ a volunteer network of nodes,
which is subject to constant churn and not as reliable as central infrastructure when it comes to availability and
enforcing access management rules.

\kms~ uses a decentralized network to remove the reliance on central service providers, proxy re-encryption for cryptographic
access controls, and a token incentive mechanism to ensure reliability, availability, and correctness.

\section{Architecture}

\subsection{Cryptographic primitives}

\subsubsection{Symmetric encryption}

Symmetric or secret key encryption requires users to know a common secret key.
For convenience, we refer to this common secret key as DEK (data encryption key).

Two operations are defined for symmetric ciphers:
\begin{align}
    c &= \text{encrypt}_{sym}(dek, d);\\
    d &= \text{decrypt}_{sym}(dek, c);
\end{align}
where $d$ is plaintext data, and $c$ is ciphertext (encrypted data).

The most useful symmetric key encryption algorithms for our purposes are AES (because it's normally hardware-accelerated)~\cite{wiki:aes}
and Salsa20~\cite{wiki:salsa20}.

Symmetric block ciphers can operate in different modes.
We use modes of operation that yield probabilistic encryption (such as GCM for AES), to guarantee strong semantic security.
For simplicity, we omit details about the particular modes of operations, treating the value of \emph{nonce} related to the mode of operation as part of the
ciphertext $c$.

\subsubsection{Public-key encryption}

Public-key encryption (PKE) is a type of encryption where two parties (a sender and a receiver) exchange information without any required common secret.
Every participant has a key pair (a public key $pk$ and a secret/private key $sk$).
If the sender has a key pair $sk_s/pk_s$ and the receiver has a key pair $sk_r/pk_r$, the sender can encrypt a message with the receiver's public key,
and the receiver can decrypt with his secret key.

Hybrid cryptosystems can be created that combine the efficiency of symmetric encryption with the convenience of PKE.
A hybrid cryptosytem encryption flow defines the functions:
\begin{align}
    dek &= \text{random}();\\
    c &= \text{encrypt}_{sym}(dek, d);\\
    edek &= \text{encrypt}_{pke}(dek, pk_r).
\end{align}
The pair $(edek, c)$ is used to transform the encrypted data.
The associated decryption by the receiver defines the functions:
\begin{align}
    dek &= \text{decrypt}_{pke}(edek, sk_r);\\
    d &= \text{decrypt}_{sym}(dek, c).
\end{align}

\subsubsection{Proxy re-encryption}
Proxy re-encryption (PRE)~\cite{wiki:pre,phd:nunez} is a type of public-key encryption (PKE) that allows a proxy entity to transform ciphertexts
from one public key to another, without learning anything about the underlying message~(\figref{fig:pre}).

\begin{figure}
\centering
    \includegraphics[width=0.6\columnwidth]{pdf/pre.pdf}
    \caption{Main actors and interactions in a PRE environment}
    \label{fig:pre}
\end{figure}

Alice, the data owner, encrypts a message $m$, with her public key $pk_A$, resulting in ciphertext $c_A$.
She decides to delegate access to message $m$ to Bob, who has the key pair $(pk_B, sk_B)$.
To do so, Alice creates a re-encryption key:
\begin{equation}
    rk_{A\rightarrow B} = \text{rekey}(sk_A, pk_B).
\end{equation}
Importantly, this re-encryption function is one way, and $rk_{A\rightarrow B}$ cannot be decomposed into its component parts
(at least, without also knowing $sk_A$ or $sk_B$).
All it can do is re-encrypt $c_A$ such that it is transformed into $c_B$:
\begin{equation}
    c_B = \text{reencrypt}(rk_{A\rightarrow B}, c_{A}).
\end{equation}
Bob can then decrypt $c_{B}$ using his secret key $sk_{B}$.

Compared to existing PKE protocols which are ideal for 1-to-1 communication, PRE is more scalable for N-to-N communication
with arbitrary numbers of data producers and consumers.
It doesn't require knowing the recipient of a message in advance, as the re-encryption token can be created and applied at any point.
This makes it well-suited for distributed systems such as blockchain, IoT, and big data~\cite{web:nucypher-hadoop}.

There are many proxy re-encryption algorithms with different properties.
For the first version of \kms~we choose the most simple (and performant) one, derived from BBS98~\cite{BBS98}.
However, sometimes we want to delegate re-encryption to multiple nodes, in order to split the trust between them and apply time-based or conditional
re-encryption policies.
In this case we use the AFGH scheme~\cite{AFGH}.
Quantum-resistant NTRU may also be used if the need arises~\cite{wiki:ntru,ntrureencrypt}.

The BBS98 algorithm creates a re-encryption key out of two secret keys, rather than a secret+public key.
However, we don't want the sender to know the receiver's secret key.
To get around this problem, we randomly generate an ephemeral key pair $sk_e/pk_e$.
Then, access delegation looks like:
\begin{align}
    sk_e &= \text{random}();\\
    rk_{A\rightarrow B} &= \text{rekey}(sk_A, sk_e);\\
    sk_e^{\prime} &= \text{encrypt}_{pke}(pk_B, sk_e).
\end{align}
The re-encryption node also needs to tell the receiver his ephemeral key.
So, in addition to $rk_{A\rightarrow B}$, the receiver will get $sk_e^{\prime}$, which will be stored by a re-encryption node along with the re-encryption key.
The decryption by the receiver will then look like:
\begin{align}
    sk_e &= \text{decrypt}_{pke}(sk_B, sk_e^{\prime});\\
    dek &= \text{decrypt}_{pke}(edek, sk_e);\\
    d &= \text{decrypt}_{sym}(dek, c).
\end{align}

\subsection{Re-encryption nodes}

When the data is stored in a cloud or decentralized storage, it is encrypted with the data owner's (\emph{sender}) key $pk_s$~(\figref{fig:arch-encrypt}).
The data itself is encrypted with a random symmetric key $dek$, with one key per file.
The $dek$, encrypted with $pk_s$ is attached to the encrypted data.
This combination $(edek, c)$ can be stored anywhere - in IPFS, Swarm, S3, or any kind of decentralized or centralized storage.
\begin{figure}
\centering
    \includegraphics[width=0.4\columnwidth]{pdf/encrypt.pdf}
    \caption{Architecture: encryption}
    \label{fig:arch-encrypt}
\end{figure}

When storing the data, the user to whom we delegate access is not necessarily known in advance.
First, the receiver should show the sender his public key~(\figref{fig:arch-delegate}).
It often makes sense for the public key to correspond to an address in the Ethereum network (then it will be shown once a transaction is made from that
address to make a payment for a digital content subscription, for example).
The sender generates a re-encryption key $re_{s\rightarrow r}$ (including an encrypted random ephemeral key when needed) and sends it to a random re-encryption
node, selected according to proof-of-stake out of the active nodes in a decentralized network.
The case where multiple nodes are selected for redundancy or security will be discussed later.
The nodes which have shared data of user \emph{sender} with a user \emph{receiver} register this information in the network.
\begin{figure}
\centering
    \includegraphics[width=0.4\columnwidth]{pdf/delegate.pdf}
    \caption{Architecture: access delegation}
    \label{fig:arch-delegate}
\end{figure}

When the receiver wants to decrypt data shared with him, he first downloads that data from storage or an encrypted stream~(\figref{fig:arch-decrypt}).
He separates out $edek$ from the message and sends $edek$ to the network of re-encryption nodes and finds active re-encryption nodes which can share the data
of the sender with the receiver (those which have re-encryption key(s) $re_{s\rightarrow r}$).
The receiver asks the node(s) that has the re-encryption key to transform $edek$ to $edek^{\prime}$ and uses his own secret key $sk_r$ to decrypt it and
obtain DEK.
Now, he can use DEK to decrypt the bulk of the data.
\begin{figure}
\centering
    \includegraphics[width=0.6\columnwidth]{pdf/decrypt.pdf}
    \caption{Architecture: decryption}
    \label{fig:arch-decrypt}
\end{figure}

\section{Network security}

In the network, there are multiple re-encryption nodes which apply access management policies.

Proxy re-encryption allows \kms~to split the trust between access management and decryption rights,
without introducing an always-online always-trusted entity (such as a traditional key management system).
Miners never see plaintext data, or anything which allows them to decrypt the data.
They are solely responsible for storing re-encryption keys and applying re-encryption functions.

The first risk of this model is collusion between a miner and a reader of the data.
If the miner gives the reader re-encryption keys for the data shared with him,
the data can be decrypted at any time by the data reader, circumventing any conditional or time-based constraints.
We counteract this threat in multiple ways: pseudo-anonymity of re-encryption keys, split-key proxy re-encryption, and a challenge protocol.
In addition, we apply economic incentives for fair operation, described in Sec.~\ref{sec:token}.

The second risk is nodes malfunctioning (returning fake data instead of performing re-encryptions).
We solve this problem using a challenge protocol.

The third risk is nodes colluding with each other to perform 50\% attacks.
This risk is usually deadly for multi-party computations (such as Enigma~\cite{enigma}). However, in our case the attacker only gains the ability to wrongfully apply re-encryption policies, not to decrypt data or to grant access to a user who hasn't been granted access to the data.
Ideally, the system should be as decentralized as possible, however 50\% attacks don't compromise the confidentiality of the data, just like 50\% attacks in
proof-of-work cryptocurrencies don't give an attacker the ability to move funds.

\subsection{Pseudo-anonymity}

It is highly beneficial for the security of the system that re-encryption nodes do not know what is it they are re-encrypting.
This prevents them from knowing which re-encryption keys to perform collusion attacks on (and trying to collude with all the network participants
is infeasible when the network is decentralized).
But pseudo-anonymity of re-encryption keys also enables us to run a challenge protocol (Sec.~\ref{sec:challenge-protocol}).

In order to achieve pseudo-anonymity, we propose the following protocol.
If each recipient of the data has a key pair $s_r/p_r$, and the path or identifier of the data shared is $n$,
each re-encryption key has a unique ID $i_r$ associated with it:
\begin{align}
    nonce &= \text{random}(), \\
    i_r &= \text{HMAC}(p_r \| n, nonce),
\end{align}
where HMAC is a hash-based message authentication code~\cite{wiki:hmac}.
The value of $i_r$ is unique and impossible to guess without knowing a random nonce.
The nonce should be told to the recipient of the data once the data is shared, so that the recipient can form a proper request to apply the re-encryption key
related to the data shared.

Re-encryption nodes store re-encryption keys $re$ in an in-memory key-value store $i_r\rightarrow re$.
The messages can be conveniently transmitted over Ethereum's Whisper protocol~\cite{eth:whisper} which conveniently supports
anonymity of encrypted messages.

\subsection{Split-key re-encryption}

Imagine that a re-encryption node decides to re-encrypt data immediately rather than to apply conditional policies as instructed.
A split-key proxy re-encryption scheme can be used to solve this problem.

Instead of one re-encryption key, m-of-m re-encryption keys can be used to produce ``re-encryption shares.''
These shares can be combined client-side.
An m-of-m scheme exists for AFGH~\cite{AFGH} encryption.
A collusion attack here would require $m$ miners \emph{and} the reader of the data.

A threshold-based m-of-n scheme, to be published by NICS Labs, appears to be the most appropriate for this task.

\subsection{Challenge protocol}
\label{sec:challenge-protocol}

There is a risk of miners returning random numbers instead of correctly re-encrypting data.
Since the data is private, users of the system cannot publish this data and their key as proof that the miner has cheated.

Provided we have pseudo-anonymity, a miner cannot distinguish between a ``true re-encryption'' and a re-encryption of random data.
So, we can produce a number of ``fake'' re-encryption keys which are designed specifically to challenge the miners.
If a miner cheats, the data and the key for this challenge aren't associated with any private data.

The miners should show the hashes of data before and after re-encryption to the network.
If this re-encryption was a challenge and the miner has cheated, challengers can present a proof that non-sensitive keys related to this challenge should actually
produce a different re-encryption result, and the miner's collateral deposit can be awarded to the challenger.

The system should also intentionally produce a number of ``wrong re-encryptions'', in order to incentivize challengers to operate, as pointed out by
Truebit~\cite{truebit}.

\section{Functionality}

\subsection{Local encryption library and daemon}

\kms~can be interfaced from a traditional, centralized application.
In Python, sharing a file in IPFS would look like:
\begin{lstlisting}[frame=single,language=Python]
import nkms
nkms.connect()  # Using default config
path = 'ipfs://QmTkzDw.../to_the_moon.avi'
nkms.share('0xab12...', path, time=86400)
\end{lstlisting}
If there is no library client available, there could be a local API server, similar to how geth is used to interact with the Ethereum network.

Reading this file would be:
\begin{lstlisting}[frame=single,language=Python]
import nkms
client = ipfsapi.Client(...)
nkms.connect()  # Using default config
path = 'ipfs://QmTkzDw.../to_the_moon.avi'
edata = client.cat(path)
data = nkms.decrypt(edata, path)
print(data)
\end{lstlisting}
The ``decrypt'' function splits edata into $edek$ and the actual encrypted data,
requests the kms network to transform $edek$ into $edek^{\prime}$,
decrypts $edek^{\prime}$ with the receiver's private key and
decrypts data with the obtained $dek$.

The preliminary version of the API will include the following functions:
\begin{itemize}
    \item connect~--- connect to the decentralized network,
        taking configuration from arguments or a config file;
    \item write~--- encrypt data with a public key corresponding to the owner of the file and save in a storage backend;
    \item read~--- download data from the storage backend, ask the decentralized network to re-encrypt, and decrypt with our private key;
    \item delete~--- delete file and re-encryption keys associated with it;
    \item decrypt~--- decrypt data which we've already read;
    \item split-edek~--- low level function to separate out encrypted symmetric encryption key from the data;
    \item share/renew/revoke~--- create a permission to read all the data we own, or a subset of it, based on file path or policy.
        The policy can include time limits and other conditions;
    \item read-policies/update-policies/delete-policies~--- read and change all the access policies we've created.
\end{itemize}

\subsection{Sharing short secrets}

Low-level functionality allows encrypting and delegating access to binary secrets (such as database credentials) or groups of these secrets without
storing them in individual files.
A possible backend for storing simple secrets like these could be a hierarchical config file (in YAML or JSON format) stored in IPFS,
or even simply in the same instance image.
Client-side software can parse this file and ask to re-encrypt only the secrets it needs.
There could be per-field and per-subfield re-encryption keys for granular permissions.

\subsection{Sharing files}

When working with files, each file and each directory is encrypted under its secret key.
Each file has its DEK stored encrypted by its secret key, directory's secret key, and so on, up to the root folder of the user.
When a directory is shared, a re-encryption key is created only for the shared directories.

\subsection{Sharing encrypted streams}

Sharing encrypted streams with multiple users is ideal for applications such as a decentralized Netflix, where third parties routing traffic
aren't permitted to see the content.

The principle is simple: each block of data in the stream is encrypted with a random DEK, and EDEK is produced using a per-channel public key.
However, it takes time to make a roundtrip with \kms.
Therefore, it makes sense to also include an EDEK of the next block of data together with the previous block.

As usual, consumers of the stream have their own key pairs and ask miner nodes to make EDEKs decryptable by the consumers.
Miners can also ensure the consumer actually paid for the subscription and refuse to re-encrypt if they did not.

\subsection{Time-based and condition-based policies}

While we don't trust miners with encrypted data or keys, we still trust them to control the duration of storing a re-encryption key.
The simplest policy is time-based: re-encryption is allowed only during the specified time interval and, if there is no time in the future when
re-encryption is allowed, the re-encryption key should be removed.

More complex policies can be created.
Re-encryption can be allowed on a condition~--- for example, pending the completion of a certain transaction.
This allows applications like pay-per-content DRM, or storing secret data as an escrow for financial transactions.

\subsection{Key rotation}

Many proxy re-encryption algorithms can be applied multiple times, BBS98~\cite{BBS98} included.
Thus, proxy re-encryption can be used for key rotation.
Key rotation allows all the EDEKs encrypted with an old key to become encrypted with a new key.

The owner of the data needs to produce re-encryption keys $re_{v1\rightarrow v2}$ between two versions of secret keys, essentially
sharing data with her future self.
Now, re-encryption nodes (assuming the encrypted storage is public, such as IPFS) will download EDEKs and apply the transformation.
For this operation, no collusion risks exist since the ``sender'' and ``receiver'' of the data are, essentially, the same person.

\section{Token economics}
\label{sec:token}

Protocol economies consist of a network of miners that contributes work to provide a scarce resource and that is
rewarded when said resource is consumed.
In \kms, miners are re-encryption nodes.
Anyone can become a miner and their rewards are differentiated based on the amount of re-encryption operations provided.
Access to the scarce re-encryption services must be controlled and allocated to the highest value uses.
The mechanism by which we achieve this is \kms~Token. \kms~Token is both the reward miners get for contributing
work and the price consumers (owners of the data) pay for access to re-encryption services.
Vitally, the token also incentivizes correctness of computation and security of the system.

\subsection{Token distribution}

All the \kms~Tokens exist from the time of creation of the system on mainnet.

Miners can hold a number of re-encryption keys proportional to the number of tokens they hold as a collateral deposit, locked by a smart contract.
The miners are paid both for providing re-encryption services and making themselves available to re-encrypt data.
The miners can be paid either by the owner of the data, or by users of the data.
The latter is more relevant for usecases where DAOs distribute content under decentralized DRM.

If miners become unavailable, they lose their ``availability'' compensation for the time period.

If miners cheat and provide wrong re-encryptions, they lose a fraction of their security deposit (Sec.~\ref{sec:challenge-protocol}).

We can disincentivize miners from leaking re-encryption keys.
Anyone can challenge a miner with a hash of a re-encryption key and, if the re-encryption key is proven to have been leaked, the miner forfeits his collateral valued in \kms~Tokens.

An interesting property of \kms~is that security improves as the number of network participants grows. As additional re-encryption
nodes enter the network, the lower the chance of collusion.
This improves both the security and censorship-resistance of the system, providing powerful network effects and meaningful first mover advantages.

Finally, in order to test the security of the network, we can put bounty secrets~--- private keys for wallets with
some crypto-currency.
Anyone is free to hack the system and take the bounty.
The fact of the bounty being taken would be proof of compromised security.
This same mechanism can be used to warn of a potential data leak by individual users of the network, by signalling that they may have exposed
their key to the data.

\section{Use cases}
\kms~provides the infrastructure for a variety of applications that require sharing of sensitive data as a basic
functionality. The ability to condition decryption operations on public actions on the consensus network, such as the publication
of certain messages, payments made between specific parties, and other events, enables a range of applications including:

\subsection{Sharing encrypted files (``Decentralized Dropbox'')}
Files can be encrypted client-side and stored in decentralized filesystems like Swarm~\cite{swarm}, IPFS~\cite{whitepaper:ipfs}, Sia~\cite{web:sia}, or Storj~\cite{web:storj}, or centralized ones like S3.
The files can be easily shared with approved third-parties by providing a re-encryption token based on the third-party's
public key.
The third-party's access permission can be easily revoked by removing the re-encryption token from the network.

\subsection{End-to-end encrypted group chat (``Encrypted Slack'')}
PRE is an ideal primitive for end-to-end encrypted group messaging, in which multiple participants require read and write
access to a channel. Members can easily be added or removed to the chat by issuing or revoking a re-encryption token.
This avoids the overhead of encrypting and sending messages multiple times, individually for each participant.

\subsection{Patient-controlled electronic health records (EHR)}
A patient-controlled EHR can be created in which the patient owns their data and encryption keys, as opposed to centralized
systems like Epic.
Again, the data can be stored centrally or in a decentralized backend.
When the patient wants to share their encrypted data with a hospital or insurance company, they issue a re-encryption token,
which grants temporary access to the third-party.

\subsection{Decentralized digital rights management (DDRM)}
Cryptographic access controls can act as a decentralized DRM.
Access controls can be embedded into the encryption itself so that they follow the data wherever it goes.
Conditional re-encryption tokens can be controlled by a smart contract and released only upon payment.
Services like a decentralized Netflix or an encrypted marketplace selling software, apps, photos, and other digital content
can now be built using \kms.

\subsection{Blind identity management}
A blind identity management service can be constructed using \kms. Identities can be encrypted client-side and stored with the
identity management provider. Users can create re-encryption keys for approved applications. The service re-encrypts identity
credentials for said third-party applications, without the identity provider ever having access.

\subsection{Secret credentials management for scripts and backend applications}
\kms~is ideal for the storage of any secrets, such as sensitive environment variables, database credentials, and API keys.
For scripts, a re-encryption token can be generated for the duration of a script, then revoked.
For example, developers can safely store encrypted database credentials on GitHub, giving temporary access to these credentials
once an instance is deployed.
Even if the GitHub repository is public, the credentials cannot be used by an unauthorized person.

\subsection{Shared credentials and enterprise password management}
\kms~can manage shared credentials that employees use to access web services.
An audit log can be built to monitor who accesses what secrets.
When an employee leaves, it is easy to revoke access or even roll keys.

\subsection{Mandatory access logging}
In some corporate and enterprise settings, clients must publish access logs for sensitive files.
This requires that each file access be recorded and conditional re-encryption can be used to mandate these logging rules.

\subsection{Mobile device management (MDM) and revocation}
In an enterprise MDM setting, re-encryption tokens can be created for valid devices. When a device is lost or retired,
or an employee leaves the organization, the re-encryption token can be deleted to revoke the device's access. This avoids the
problem of re-organizing hierarchical key trees.

\section{Summary}
\kms~is a decentralized key management service and cryptographic access control layer for the blockchain and
decentralized applications.
Developers and enterprises alike can leverage it to create highly-secure applications in healthcare,
financial services, and more.
By bringing private data sharing and computation to the public blockchain, \kms~enables everything from encrypted
content marketplaces to secret credentials management to patient-controlled electronic health records.

\section{Acknowledgements}
We would like to thank David Nu{\~n}ez and Isaac Agudo Ruiz from University of M{\'a}laga
for their help with proxy re-encryption algorithms and for inspiration given by David's thesis.
We also thank Dave Evans at the University of Virginia for advising our company throughout its lifetime
and his help with regards to the current state of the art in multi-party computation.
And thank Stefano Bernardi, Tom Ding, and many others for their help on token economics.

\bibliography{kms-whitepaper}

\end{document}
