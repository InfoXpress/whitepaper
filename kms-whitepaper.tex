\documentclass[notitlepage,longbibliography]{revtex4-1}

% NuCypherKMS
\newcommand{\kms}{NuCypherKMS}

\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=5pt]{subfig}
\usepackage[usenames]{color}
\usepackage{librebaskerville}
% \usepackage{xspace}
\definecolor{darkgreen}{rgb}{0.00,0.50,0.25}
\definecolor{darkblue}{rgb}{0.00,0.00,0.67}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\usepackage[breaklinks,pdftitle={SmartKMS: blockchain-based encryption as a service}, pdfauthor={Michael Egorov},colorlinks,urlcolor=blue,citecolor=darkgreen,linkcolor=darkblue]{hyperref}
\usepackage[usenames]{color}
\graphicspath{{pdf/}}

\begin{document}

\title{\kms: Decentralized key management as a service}

\author{M. Egorov}
\email{michael@nucypher.com}
\author{M. Wilkison}
\email{maclane@nucypher.com}
\affiliation{NuCypher}

% TODO: include David Nunez when he agrees

\begin{abstract}
    \kms~is a decentralized, censorship-resistant Key Management System that addresses the limitations of using consensus
    networks to securely store and operate on encrypted data~\cite{cryptoeprint:2017:201}.
    It provides encryption and cryptographic access controls as a service, performed by a decentralized network,
    leveraging proxy re-encryption~\cite{wiki:pre}.
    Unlike centralized KMS as a service solutions, it doesn't require trusting a service provider.
    \kms~enables sharing of sensitive data for both decentralized and centralized applications,
    providing security infrastructure for applications from healthcare to identity management to decentralized content marketplaces.
\end{abstract}

\date{\today}
\maketitle

\newpage
\tableofcontents
\newpage

\section{Introduction}

\kms~is a decentralized key management system (KMS), encryption, and access control service.
It enables private data sharing between arbitrary number of participants in public consensus networks,
using a hybrid cryptosystem that combines the efficiency of symmetric encryption with the convenience of public-key encryption.
In-network tokens are used to incentivize network participants to perform key management and access delegation/revocation operations.

\subsection{Background}
A key management system (KMS) is an integrated approach for generating, distributing and managing cryptographic keys for devices and
applications.
A KMS includes the backend functionality for key generation, distribution, and rotation as well as the client functionality for
injecting, storing, and managing keys on devices~\cite{wiki:kms}.

As the root of trust, it's critical that a KMS is appropriately configured, managed, and protected.
Historically, this has meant deploying a KMS on-premises in hardware security modules (HSM)~\cite{wiki:hsm} or using tools like
HashiCorp's Vault~\cite{web:hashicorp-vault}.
However, this requires a high degree of technical sophistication as well as upfront capital investment.
To ease the technical burden and provide more competitive economics, vendors like Amazon CloudHSM~\cite{web:aws-cloudhsm},
Google Cloud KMS~\cite{web:google-cloud-kms}, Azure Key Vault~\cite{web:azure-key-vault} and TrueVault~\cite{web:truevault}
have begun offering KMS as a service.
However, KMS as a service offerings necessitate placing an undo level of trust in the service provider, which may
be inappropriate for security-critical applications.

Public consensus networks, such as Bitcoin and Ethereum, are a promising solution to this centralization problem.
But the limitations of public consensus networks to perform cryptographic operations that involve the manipulation of secret
data are well-established~\cite{cryptoeprint:2017:201}. Consensus networks employ a volunteer network of nodes,
which is subject to constant churn and not as reliable as central infrastructure when it comes to enforcing access management rules. 

NuCypherKMS enables KMS as a service. It uses a decentralized network to remove the trusted relationship with central service
providers and a token incentive mechanism to ensure reliability, availability, and correctness.

\section{Architecture}

\subsection{Cryptographic primitives}

\subsubsection{Symmetric encryption}

Symmetric or secret key encryption requires users to know a common secret key.
For convenience, we refer to this common secret key as DEK (data encryption key).

Two operations are defined for symmetric ciphers:
\begin{align}
    c &= \text{encrypt}_{sym}(dek, d);\\
    d &= \text{decrypt}_{sym}(dek, c);
\end{align}
where $d$ is plaintext data, and $c$ is ciphertext (encrypted data).

The most useful symmetric key encryption algorithms for our purposes are AES (because it's normally hardware-accelerated)~\cite{wiki:aes}
and Salsa20~\cite{wiki:salsa20}.

Symmetric block ciphers can operate in different modes.
We use modes of operation that yield probabilistic encryption (such as GCM for AES), to guarantee strong semantic security.
For simplicity, we omit details about the particular modes of operations, saying that the value of \emph{nonce} related to the mode of operation is a part of the
ciphertext $c$.

\subsubsection{Public-key encryption}

Public-key encryption (PKE) is a type of encryption where two parties (a sender and receiver) exchange information without any required common secret.
Every participant has a key pair (a public $pk$ and a secret/private key $sk$).
If the sender has a key pair $sk_s/pk_s$ and the receiver has a key pair $sk_r/pk_r$, the sender can encrypt a message with the receiver's public key,
and the receiver can decrypt with his secret key.

Hybrid cryptosystems can be created that combine the efficiency of symmetric encryption with the convenience of PKE.
A hybrid cryptosytem encryption flow defines the functions:
\begin{align}
    dek &= \text{random}();\\
    c &= \text{encrypt}_{sym}(dek, d);\\
    edek &= \text{encrypt}_{pke}(dek, pk_r).
\end{align}
The pair $(edek, c)$ is used to transfer the encrypted data.
The associated decryption by the receiver defines the functions:
\begin{align}
    dek &= \text{decrypt}_{pke}(edek, sk_r);\\
    d &= \text{decrypt}_{sym}(dek, c).
\end{align}

\subsubsection{Proxy re-encryption}
Proxy re-encryption (PRE)~\cite{wiki:pre,phd:nunez} is a type of public-key encryption (PKE) that allows a proxy entity to transform ciphertexts
from one public key to another, without learning anything about the underlying message~(Fig.~\ref{fig:pre}).

\begin{figure}
\centering
    \includegraphics[width=0.6\columnwidth]{pdf/pre.png}  % XXX to be replaced with a vector re-draw
    \caption{Main actors and interactions in a PRE environment}
    \label{fig:pre}
\end{figure}

Alice, the data owner, encrypts a message $m$, with her public key $pk_A$, resulting in ciphertext $c_A$.
She decides to delegate access to message $m$ to Bob, who has the key pair $(pk_B, sk_B)$.
To do so, Alice creates a re-encryption key:
\begin{equation}
    rk_{A\rightarrow B} = \text{rekey}(sk_A, pk_B).
\end{equation}
Importantly, this re-encryption function is one way, and $rk_{A\rightarrow B}$ cannot be decomposed into its component parts
(at least, without also knowing $sk_A$ or $sk_B$).
All it can do is re-encrypt $c_A$ such that it is transformed into $c_B$:
\begin{equation}
    c_B = \text{reencrypt}(rk_{A\rightarrow B}, c_{A}).
\end{equation}
Bob can then decrypt $c_{B}$ using his secret key $sk_{B}$.

Compared to existing PKE protocols which are ideal for 1-to-1 communication, PRE is more scalable for N-to-N communication
with arbitrary numbers of data producers and consumers.
It doesn't require knowing the recipient of a message in advance, as the re-encryption token can be created and applied at any point.
This makes it well-suited for distributed systems such as blockchain, IoT, and big data~\cite{web:nucypher-hadoop}.

There are many proxy re-encryption algorithms, with different properties.
For the first version of \kms~we choose the most simple (and performant) one, derived from BBS98~\cite{BBS98}.
However, sometimes we want to delegate re-encryption to multiple nodes, in order to split the trust between them and apply time-based or conditional
re-encryption policies.
In this case we use the AFGH scheme~\cite{AFGH}.
Quantum-resistant NTRU may also be used if the need arises~\cite{wiki:ntru,ntrureencrypt}.

The BBS98 algorithm creates a re-encryption key out of two secret keys, rather than a secret+public key.
However, we don't want the sender to know the receiver's secret key.
To get around this problem, we randomly generate an ephemeral key pair $sk_e/pk_e$.
Then, access delegation looks like:
\begin{align}
    sk_e &= \text{random}();\\
    rk_{A\rightarrow B} &= \text{rekey}(sk_A, sk_e);\\
    sk_e^{\prime} &= \text{encrypt}_{pke}(pk_B, sk_e).
\end{align}
The re-encryption node also needs to tell the receiver his ephemeral key.
So, in addition to $rk_{A\rightarrow B}$, the receiver will get $sk_e^{\prime}$, which will be stored by a re-encryption node along with the re-encryption key.
The decryption by the receiver will then look like:
\begin{align}
    sk_e &= \text{decrypt}_{pke}(sk_B, sk_e^{\prime});\\
    dek &= \text{decrypt}_{pke}(edek, sk_e);\\
    d &= \text{decrypt}_{sym}(dek, c).
\end{align}

\subsection{Re-encryption nodes}

When the data is stored in a cloud or decentralized storage, it is encrypted with data owner's (\emph{sender}) key $pk_s$~(Fig.~\ref{fig:arch-encrypt}).
The data itself is encrypted with a random symmetric key $dek$, with one key per file.
The $dek$, encrypted with $pk_s$ is attached to the encrypted data.
This combination $(edek, c)$ can be stored anywhere - in IPFS, S3, or any kind of decentralized or centralized storage.
\begin{figure}
\centering
    \includegraphics[width=0.4\columnwidth]{pdf/encrypt.pdf}
    \caption{Architecture: encryption}
    \label{fig:arch-encrypt}
\end{figure}

When storing the data, the user who we delegate access to is not necessarily known in advance.
First, the receiver should show the sender his public key~(Fig.~\ref{fig:arch-delegate}).
It often makes sense for the public key to correspond to an address in the Ethereum network (then it will be shown once a transaction is made from that
address to make a payment for a digital content subscription, for example).
The sender generates a reencryption key $re_{s\rightarrow r}$ (including an encrypted random ephemeral key when needed) and sends it to a random re-encryption
node, selected according to proof-of-stake out of the active nodes in a decentralized network.
The case where multiple nodes are selected for redundancy or security will be discussed later.
The nodes which have shared data of user \emph{sender} with a user \emph{receiver} register this information in the network.
\begin{figure}
\centering
    \includegraphics[width=0.4\columnwidth]{pdf/delegate.pdf}
    \caption{Architecture: access delegation}
    \label{fig:arch-delegate}
\end{figure}

When the receiver wants to decrypt data shared with him, he first downloads that data from storage or an encrypted stream~(Fig.~\ref{fig:arch-decrypt}).
He separates out EDEK from the message and sends $edek$ to the network of re-encryption nodes and finds active re-encryption nodes which can share the data
of the sender with the receiver (those which have re-encryption key(s) $re_{s\rightarrow r}$).
The receiver asks the node(s) that has the re-encryption key to transform $edek$ to $edek^{\prime}$ and uses his own secret key $sk_r$ to decrypt it and
obtain DEK.
Now, he can use DEK to decrypt the bulk of the data.
\begin{figure}
\centering
    \includegraphics[width=0.6\columnwidth]{pdf/decrypt.pdf}
    \caption{Architecture: decryption}
    \label{fig:arch-decrypt}
\end{figure}

\section{Functionality}

\subsection{Local encryption library and daemon}

\kms~can be interfaced from a traditional, centralized application.
In Python, sharing a file in IPFS would look like:
\begin{lstlisting}[frame=single,language=Python]
import smartkms as kms
kms.connect()  # Using default config
path = '/ipfs/QmTkzDw.../to_the_moon.avi'
kms.share('0xab12...', path, time=86400)
\end{lstlisting}
If there is no library client available, there could be a local API server, similarly to how geth is used to interact with Ethereum network.

Reading this file would be:
\begin{lstlisting}[frame=single,language=Python]
import smartkms as kms
client = ipfsapi.Client(...)
kms.connect()  # Using default config
path = '/ipfs/QmTkzDw.../to_the_moon.avi'
edata = client.cat(path)
data = kms.decrypt(edata, path)
print(data)
\end{lstlisting}
The ``decrypt'' function splits edata into $edek$ and the actual encrypted data,
requests the kms network to transform $edek$ into $edek^{\prime}$,
decrypts $edek^{\prime}$ with receiver's private key and
decrypts data with the obtained $dek$.

The preliminary version of the API will include the following functions:
\begin{itemize}
    \item connect~--- connect to the decentralized network,
        taking configuration from arguments or a config file;
    \item write~--- encrypt data with a public key corresponding to the owner of the file and save in a storage backend;
    \item read~--- download data from the storage backend, ask the decentralized network to re-encrypt, and decrypt with our private key;
    \item delete~--- delete file and re-encryption keys associated with it;
    \item decrypt~--- decrypt data which we've already read;
    \item split-edek~--- low level function to separate out encrypted symmetric encryption key from the data;
    \item share/renew/revoke~--- create a permission to read all the data we own, or subset of it, based on file path or policy.
        The policy can include time limits and other conditions;
    \item read-policies/update-policies/delete-policies~--- read and change all the access policies we've created.
\end{itemize}

\subsection{Sharing short secrets}

Low-level functionality allows encrypting and delegating access to binary secrets (such as database credentials) or groups of these secrets without
storing them in individual files.
A possible backend for storing simple secrets like these could be a hierarchical config file (in YAML or JSON format) stored in IPFS.
Client-side software can parse this file and ask to re-encrypt only the secrets it needs.
There could be per-field and per-subfield re-encryption keys for granular permissions.

\subsection{Sharing files}

When working with files, each file and each directory is encrypted under its secret key.
Each file has its DEK stored encrypted by its secret key, directory's secret key, and so on, up to the root folder of the user.
When a directory is shared, a re-encryption key is created only for the shared directories.

\subsection{Sharing encrypted streams}

Sharing encrypted streams with multiple users is ideal for applications such as a decentralized Netflix, where third parties routing traffic
aren't permitted to see the content.

The principle is simple: each block of data in the stream is encrypted with a random DEK, and EDEK is produced using a per-channel public key.
However, it takes time to make a roundtrip with \kms.
Therefore, it makes sense to also include an EDEK of the next block of data together with the previous block.

As usual, consumers of the stream have their own key pairs and ask miner nodes to make EDEKs decryptable by the consumers.
Miners can also ensure the consumer actually paid for the subscription and refuse to re-encrypt if they didn't.

\subsection{Time-based and condition-based policies}

While we don't trust miners with encrypted data or keys, we still trust them to control the duration of storing a re-encryption key.
The simplest policy is time-based: reencryption is allowed only during the specified time interval and, if there is no time in the future when
reencryption is allowed, the reencryption key should be removed.

More complex policies can be created.
Re-encryption can be allowed on a condition~--- for example, pending the completion of a certain transaction.
This allows applications like pay-per-content DRM, or storing secret data as an escrow for financial transactions (lending).

\subsection{Key rotation}

Many proxy re-encryption algorithms can be applied multiple times, and BBS98~\cite{BBS98} is one of them.
Thus, proxy re-encryption can be used for key rotation.
Key rotation allows all the EDEK encrypted with an old version of a key to become encrypted with a new version of a key.

The owner of the data needs to produce re-encryption keys $re_{v1\rightarrow v2}$ between two versions of secret keys, essentially
sharing data with his future self.
Now, re-encryption nodes (assuming the encrypted storage is public, such as IPFS) will download EDEKs and apply the transformation.
For this operation, no collusion risks exist since the ``sender'' and ``receiver'' of the data are, essentially, the same person.

\section{Token economics}
Protocol economies consist of a network of miners that contributes work to provide a scarce resource and that is
rewarded when said resource is consumed.
In \kms, miners are re-encryption nodes.
Anyone can become a miner and their rewards are differentiated based on the amount of re-encryption operations provided.
Access to the scarce re-encryption services must be controlled and allocated to the most high value uses.
The mechanism by which we achieve this is \kms~Token. \kms~Token is both the reward miners get for contributing
work and the price consumers (owners of the data) pay for access to re-encryption services.

\subsection{Functionality and necessity}
% what does the token do?
% why is the token necessary at all?
First, miners have a quota on the number of operations they can perform according to the amount of \kms~Token they are holding.
Thus, \kms~Token serves as a way to decentralize the network in order to avoid collusion between miners and users of the data.
It also is used as collateral which miners risk if they commit any wrongdoing (such as providing fake data instead of re-encrypted data, leaking
re-encryption keys, or being offline for too long while claiming to be active guardians of re-encryption policies).

Quotas are distributed proportional to the number of online (Staking) miners' tokens,
where the miners promise to be online and hold/process up to a certain amount of re-encryption keys,
while their tokens are locked up by a smart contract.

\subsection{Incentives}
% how do the tokens create and incentivize an economy around the protocol?
% how do token holders benefit from that growing cryptoeconomy?

\subsection{Issuance mechanism}
% how are tokens minted/destroyed/used?

\section{Security considerations}

Proxy re-encryption allows \kms~to split the trust between access management and decryption rights,
without introducing an always-online always-trusted entity (such as a traditional key management system).
Miners never see plaintext data, or anything which allows them to decrypt the data.
They are solely responsible for storing re-encryption keys and applying re-encryption functions.

\subsection{Collusion}
The first risk is collusion of a miner and a reader of the data.
If the miner gives the reader re-encryption keys for the data shared with him,
the data can be decrypted at any time by the data reader, circumventing any conditional or time-based constraints.
This risk can be mitigated in several ways.

First of all, instead of one re-encryption key, m-of-n re-encryption keys can be used to produce ``re-encryption shares''.
These shares can be combined client-side.
This scheme can be used with AFGH~\cite{AFGH} encryption, for example.
A ``collusion'' attack here would require $m$ miners \emph{and} the reader of the data.

Secondly, we can disincentivize miners from leaking re-encryption keys.
Anyone can challenge a miner with a hash of a re-encryption key and, if the re-encryption key is proven to have been leaked, the miner forfeits his collateral valued in \kms~Tokens.

Finally, in order to test the security of the network (non-collusion), we can put bounty secrets~--- private keys for wallets with
some crypto-currency.
Anyone is free to hack the system and take the bounty.
The fact of the bounty being taken would be proof of security being compromised.
This same mechanism can be used to warn of a potential data leak by individual users of the network, by signalling that they may have exposed
their key to the data.

\subsection{51\% attack}
NuCypherKMS provides superior security guarantees than an alternative scheme in which private keys are split and stored across nodes.
Under a split key scheme, if a malicious actor is able to compromise enough nodes and gather a sufficent number of key shares, they
will be able to decrypt the target data.
In contrast, if an attacker is able to gather a sufficient number of re-encryption tokens, they will only be able to re-encrypt the data
to the target key, a dramatic increase in security and confidentiality guarantees.

\subsection{Misbehaving nodes}
Re-encryption nodes may fraudulently return random data instead of appropriately re-encrypted ciphertext.

\section{Use cases}
\kms~provides the infrastructure for a variety of applications that require sharing of sensitive data as a basic
functionality, including:

\subsection{Sharing encrypted files (``Decentralized dropbox'')}
Files can be encrypted client-side and stored in decentralized filesystems like IPFS (or centralized ones like S3), Sia~\cite{web:sia}, or Storj~\cite{web:storj}.
The files can be easily shared with approved third-parties by providing a re-encryption token based on the third-party's
public key.
The third-party's access permission can be easily revoked by removing the re-encryption token from the network.

\subsection{End-to-end encrypted group chat}
PRE is an ideal primitive for end-to-end encrypted group messaging, in which multiple participants require read and write
access to a channel. Members can easily be added or removed to the chat by issuing or revoking a re-encryption token.
This avoids the overhead of encrypting and sending messages multiple times, individually for each participant.

\subsection{Patient-controlled electronic health records (EHR)}
A patient-controlled EHR can be created in which the patient owns their data and encryption keys, as opposed to centralized
systems like Epic.
Again, the data can be stored centrally or in a decentralized backend.
When the patient wants to share their encrypted data with a hospital or insurance company, they issue a re-encryption token,
which grants temporary access to the third-party.

\subsection{Decentralized digital rights management (DDRM)}
Cryptographic access controls can act as a kind of decentralized DRM.
Access controls can be embedeed into the encryption itself so that they follow the data wherever it goes.
Conditional re-encryption tokens can be controlled by a smart contract and released only upon payment.
Services like a decentralized Netflix or an encrypted marketplace selling software, apps, photos, and other content
can now be built using \kms.

\subsection{Blind identity management}
A blind identity management service can be constructed using \kms. Identities can be encrypted client-side and stored with the
identity management provider. Users can create re-encryption keys for approved applications. The service re-encrypts identity
credentials for said third-party applications, without the identity provider ever having access.

\subsection{Secret credentials management for scripts and backend applications}
\kms~is ideal for the storage of any secrets, such as sensitive environment variables, database credentials, and API keys.
It can be used for shared credentials that employees use to access web services.
An audit log mechanism could be built to monitor what secrets are accessed and by whom.
When an employee leaves, it is easy to revoke access or even roll keys.
For scripts, a re-encryption token can be generated for the duration of a script, then revoked.

\bibliography{kms-whitepaper}

\end{document}
