\documentclass[notitlepage,longbibliography]{revtex4-1}

% Project name
\newcommand{\kms}{SmartKMS}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=5pt]{subfig}
\usepackage[usenames]{color}
\usepackage{librebaskerville}
% \usepackage{xspace}
\definecolor{darkgreen}{rgb}{0.00,0.50,0.25}
\definecolor{darkblue}{rgb}{0.00,0.00,0.67}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\usepackage[breaklinks,pdftitle={SmartKMS: blockchain-based encryption as a service}, pdfauthor={Michael Egorov},colorlinks,urlcolor=blue,citecolor=darkgreen,linkcolor=darkblue]{hyperref}
\usepackage[usenames]{color}
\graphicspath{{pdf/}}

\begin{document}

\title{\kms~--- blockchain-based key management as a service}

\author{M. Egorov}
\email{michael@nucypher.com}
\author{M. Wilkison}
\email{maclane@nucypher.com}
\affiliation{NuCypher}

% TODO: include David Nunez when he agrees

\begin{abstract}
    \kms~is a global, decentralized Key Management System.
    It provides encryption and cryptographic access controls as a service, performed by a decentralized network,
    with the help of proxy re-encryption~\cite{wiki:pre}.
    Importantly, it doesn't rely on trusting a service provider, unlike centralized encryption-as-a-service solutions.
    \kms~enables sharing of sensitive data for both decentralized and centralized applications,
    providing the infrastructure for applications from healthcare to identity to decentralized content marketplaces.
\end{abstract}

\date{\today}
\maketitle

\section{Introduction}

The \kms~is a blockchain-based encryption and access control management as a service.
It enables secure private data sharing between arbitrary number of participants in public and/or decentralized networks.
Key Management Tokens (KMT) are used to perform key management and access delegation/revokation operations.

(Overview of encryption: symmetric encryption, public key encryption, encryption at rest, TLS).

(Overview of key management systems: what they do, why, KMS as a service - CloudHSM, truevault; self-run: hashicorp).

(Brief statement that we enable KMSaas with combination of blockchain and PRE)

\section{Architecture}

\subsection{Cryptographic primitives}
Proxy re-encryption (PRE) is a type of public-key encryption (PKE) that allows a proxy entity to transform ciphertexts
from one public key to another, without learning anything about the underlying message.
Compared to existing PKE protocols which are ideal for 1-to-1 communication, PRE is more scalable for N-to-N communication
with arbitrary numbers of producers and consumers.
This makes it well-suited for distributed systems such as blockchain, distributed networks, and big data~\cite{web:nucypher-hadoop}.

A simple PRE workflow is illustrated in Figure~\ref{fig-pre}.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{pre.png}
\caption{Main actors and interactions in a PRE environment}\label{fig-pre}
\end{figure}

Alice, the data owner, encrypts a message $m$, with her public key $pk_{A}$, resulting in ciphertext $c_{A}$.
She decides to delegate access to message m to Bob who has the key pair $(pk_{B}, sk_{B})$.
To do so, Alice creates a re-encryption key $rk_{A->B}$, which is created by applying a function to her secret key $sk_{A}$ and
Bobâ€™s public key $pk_{B}$.
Importantly, this re-encryption function is one way, and $rk_{A->B}$ cannot be decomposed into its component parts.
All it can do is re-encrypt $c_{A}$ such that it is transformed into $c_{B}$, where $c_{B}$ = $ReEnc(rk_{A->B}, c_{A})$.
Bob can then decrypt $c_{B}$ using his secret key $sk_{B}$.

\subsection{Re-encryption nodes}

\subsection{Local encryption library and daemon}

\section{Functionality}

\subsection{Sharing short secrets}

\subsection{Sharing files}

\subsection{Sharing encrypted streams}

\subsection{Time-based and condition-based policies}

\subsection{Policies controlled by smart contracts}

\subsection{Protocol extendibility}

\section{Economics}

\section{Use cases}
\kms~provides the infrastructure for a variety of applications that require sharing of sensitive data as a basic
functionality, including:

\subsection{Sharing encrypted files (``Decentralized dropbox'')}
Files can be encrypted client-side and stored in decentralized filesystems like IPFS (or centralized ones like S3).
The files can be easily shared with approved third-parties by providing a re-encryption token based on the third-parties
public key.
The third-parties access permission can be easily revoked by removing the re-encryption token from the network.

\subsection{End-to-end encrypted group chat}
PRE is an ideal primitive for end-to-end encrypted group messaging, in which multiple participants require read and write
access to a channel. Members can easily be added or removed to the chat by issuing or revoking a re-encryption token.
This avoids the overhead of encrypting and sending messages multiple times, individually for each participant.

\subsection{Patient-controlled electronic health records (EHR)}
A patient-controlled EHR can be created in the patient owns their data and encryption keys, as opposed to an centralized
company like Epic.
Again, the data can be stored centrally or in a decentralized system.
When the patient wants to share their encrypted data with a hospital or insurance company, they issue a re-encryption token,
which grants temporary access to the third-party.

\subsection{Decentralized digital rights management (DDRM)}
Cryptographic access controls can act as a kind of decentralized DRM.
Access controls can be embedeed into the encryption itself so that they follow the data wherever it goes.
Conditional re-encryption tokens can be controlled by a smart contract and released only upon payment.
Services like a decentralized Netflix or an encrypted marketplace selling software, apps, photos, and other content
can now be built using \kms.

\subsection{Identity management}

\subsection{Secret credentials management for scripts and backend applications}
\kms~is ideal for the storage of any secrets, such as sensitive environment variables, database credentials, and API keys.
It can be used for shared credentials that employees use to access web services.
An audit log mechanism could be built to monitor what secrets are accessed and by whom.
When an employee leaves, it is easy to revoke access or even roll keys.
For scripts, a re-encryption token can be generated for the duration of a script, then revoked.

\section{Security risks}

\begin{itemize}
    \item Split trust;
    \item Node collusion;
    \item Disinsentivising leakage of a re-encryption key.
\end{itemize}

\section{Proposed roadmap}

\bibliography{kms-whitepaper}

\end{document}
